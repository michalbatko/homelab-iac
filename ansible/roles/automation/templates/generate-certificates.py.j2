#!/usr/bin/env python3

import yaml
import subprocess
import sys
import logging
from pathlib import Path
import os

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/letsencrypt/certificate-manager.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class CertificateGenerator:
    ADMIN_EMAIL = 'admin@batko.me'
    
    def __init__(self, registry_path='/etc/letsencrypt/certificate-registry.yml'):
        self.registry_path = registry_path
        self.registry = self._load_registry()
        self.letsencrypt_dir = Path('/etc/letsencrypt/live')
        self.playbook_dir = Path('/etc/letsencrypt/deployment')
        self.inventory_path = '/etc/ansible/hosts.yml'
    
    def _load_registry(self):
        try:
            with open(self.registry_path, 'r') as f:
                registry = yaml.safe_load(f)
                logger.info(f"Loaded certificate registry containing {len(registry.get('certificates', {}))} definitions")
                return registry
        except FileNotFoundError:
            logger.error(f"Cannot open certificate registry '{self.registry_path}': No such file or directory")
            sys.exit(1)
        except yaml.YAMLError as e:
            logger.error(f"Cannot parse certificate registry: {e}")
            sys.exit(1)

    def sync_certificates(self):
        sync_playbook = self.playbook_dir / 'sync-certificates.yml'
        
        if not sync_playbook.exists():
            logger.error(f"Cannot open synchronization playbook '{sync_playbook}': No such file or directory")
            return False
        
        cmd = [
            '/usr/bin/sudo', '-u', 'actions-runner',
            'ansible-playbook',
            str(sync_playbook),
            '-i', self.inventory_path
        ]
        
        logger.info("Synchronizing certificates between automation hosts")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, cwd='/etc/letsencrypt')
            
            if result.stdout:
                logger.info(f"Synchronization playbook output:\n{result.stdout}")
            
            if result.returncode == 0:
                logger.info("Certificate synchronization completed successfully")
                return True
            else:
                if result.stderr:
                    logger.error(f"Certificate synchronization failed: {result.stderr.strip()}")
                return False
        
        except Exception as e:
            logger.error(f"Certificate synchronization failed: {e}")
            return False

    def certificate_exists(self, domain_name):
        cert_path = self.letsencrypt_dir / domain_name / 'fullchain.pem'
        return cert_path.exists()
    
    def generate_certificate(self, domain_name):
        if domain_name not in self.registry['certificates']:
            logger.error(f"Domain '{domain_name}' not found in registry")
            return False, False
        
        cert_config = self.registry['certificates'][domain_name]
        domains = cert_config['domains']
        
        if self.certificate_exists(domain_name):
            logger.info(f"Certificate for {domain_name} already exists")
            return True, False
        
        cmd = [
            'certbot', 'certonly',
            '--dns-cloudflare',
            '--dns-cloudflare-credentials', '/etc/letsencrypt/cloudflare.ini',
            '--non-interactive',
            '--agree-tos',
            '-m', self.ADMIN_EMAIL
        ]
        
        for domain in domains:
            cmd.extend(['-d', domain])
        
        logger.info(f"Generating certificate for {domain_name}: {', '.join(domains)}")
        
        try:
            result = subprocess.run(cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                logger.info(f"Certificate generated successfully: {domain_name}")
                return True, True
            else:
                logger.error(f"Certificate generation failed: {result.stderr.strip()}")
                return False, False
         
        except Exception as e:
            logger.error(f"Certificate generation failed: {e}")
            return False, False
    
    def generate_all_certificates(self):
        certificates = self.registry.get('certificates', {})
        
        if not certificates:
            logger.info("Certificate registry contains no certificate definitions")
            return True, False

        logger.info(f"Starting certificate generation for {len(certificates)} domains")

        generated_count = 0
        failed_count = 0
        
        for domain_name in certificates.keys():
            success, was_generated = self.generate_certificate(domain_name)
            if was_generated:
                generated_count += 1
            elif not success:
                failed_count += 1
        
        if generated_count > 0:
            logger.info(f"[STATE_CHANGE] Successfully generated {generated_count} certificates")
        else:
            logger.info("All certificates already exist")

        if failed_count > 0:
            logger.error(f"Failed to generate {failed_count} certificates")
        
        return failed_count == 0, generated_count > 0

def main():
    if os.geteuid() != 0:
        logger.error("Script must be executed with root privileges")
        sys.exit(1)
    
    try:
        generator = CertificateGenerator()
        
        logger.info("Pre-generation synchronization")
        if not generator.sync_certificates():
            logger.error("Pre-generation synchronization failed")
            sys.exit(1)

        logger.info("Generating certificates")
        generation_success, certificates_generated = generator.generate_all_certificates()
        if not generation_success:
            logger.error("Certificate generation failed")
            sys.exit(1)
        
        if certificates_generated:
            logger.info("Post-generation synchronization")
            if not generator.sync_certificates():
                logger.error("Post-generation synchronization failed")
                sys.exit(1)
        else:
            logger.info("No new certificates generated")
        
        logger.info("Completed certificate generation and synchronization")
        sys.exit(0)
    
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
